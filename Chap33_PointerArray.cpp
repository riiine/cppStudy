#include <iostream>

/** 문자열 관련 라이브러리*/
#include <string>
/** 배열의 사이즈를 알기 위한 라이브러리*/
#include <array>

/** C++ 표준 라이브러리 사용합니다. */
using namespace std;

int main()
{
    /**
    1. 배열과 포인터
    2. 배열포인터
    3. 포인터배열

    포인터 배열을 자세하게 알기 위해서는 이중 for문, 2차원 배열의 지식이 필요합니다.
    */

    /** 구구단을 만들어 봅니다. */
    for (int i = 2; i <= 9; i++)
    {
        for (int j = 1; j <= 9; j++)
        {
            cout << i << " + " << j << " = " << i * j << endl;
        }
    }

    cout << "" << endl;
    cout << "" << endl;

    /**
    Row : 행, Column : 열

    세로 크기(행)가 3이고 가로 크기(열)이 4인 int타입의 2차원 배열을 선언합니다.
    */
    int numArr[3][4] =
    {
        {11, 22, 33, 44},
        {55, 66, 77, 88},
        {99, 110, 121, 132}
    };
    /** 11 : 세로 인덱스 0, 가로 인덱스 0인 요소 출력*/
    cout << "numArr[0][0] : " << numArr[0][0] << endl;
    /** 77 : 세로 인덱스 1, 가로 인덱스 2인 요소 출력*/
    cout << "numArr[1][2] : " << numArr[1][2] << endl;
    /** 99 : 세로 인덱스 2, 가로 인덱스 0인 요소 출럭*/
    cout << "numArr[2][0] : " << numArr[2][0] << endl;
    /** 132 : 세로 인덱스 2, 가로 인덱스 3인 요소 출력*/
    cout << "numArr[2][3] : " << numArr[2][3] << endl;

    cout << "" << endl;
    cout << "" << endl;

    /**
    행을 구하는 공식 :
    현재 2차원 배열의 행(세로 크기)의 사이즈는 3입니다.
    2차원 배열의 세로 크기를 구할 때는
    배열이 차지하는 전체공간을 가로 한 줄의 크기로 나눠 줍니다.
    */
    int row = sizeof(numArr) / sizeof(numArr[0]);
    cout << "row : " << row << endl;
    cout << "" << endl;

    /**
    열을 구하는 공식 :
    현재 2차원 배열의 열(가로 크기)의 사이즈는 4입니다.
    2차원 배열의 가로 크기를 구할 때는
    가로 한줄의 크기를 요소의 크기로 나눠줍니다.
    */
    int col = sizeof(numArr[0]) / sizeof(int);
    cout << "col : " << col << endl;
    cout << "" << endl;

    /**
    반복문으로 2차원 배열의 요소들을 출력합니다.
    세로 크기와 가로 크기를 이미 구해 놓았습니다.
    반복문으로 세로부터 반복한 뒤, 가로를 반복하면서 2차원 배열의 요소를 출력합니다.
    */

    /** 2차원 배열의 세로 크기만큼 반복*/
    for (int i = 0; i < row; i++)
    {
        /** 2차원 배열의 가로 크기만큼 반복*/
        for (int j = 0; j < col; j++)
        {
            /**
            반복문의 지역변수 i와 j는 증감문으로 1씩 증가하므로
            2차원 배열의 세로 인덱스에는 i의 값을
            2차원 배열의 가로 인덱스에는 j의 값을 넣으면
            배열의 요소를 순서대로 접근할 수 있습니다.
            */
            cout << numArr[i][j] << " ";
        }
        /** 가로 요소를 출력한 뒤에 다음 줄로 넘어갑니다. */
        cout << "" << endl;
    }

    cout << "" << endl;
    cout << "" << endl;

    /** 포인터 배열은 배열 하나가 아닌 여러개의 배열을 한번에 처리할 수 있는 엄청난 효율이 있습니다. */

    /**
    2차원 배열의 요소들을 역순으로 출력해 봅니다.
    이미 세로 사이즈(행), 가로 사이즈(열)은 미리 구해 놓았습니다.
    반복문의 초기값에 배열의 세로 크기와 가로 크기를 바로 넣어 버리면
    처음부터 배열의 인덱스를 벗어난 상태가 됩니다.
    배열의 인덱스는 0부터 시작하기 때문입니다.
    따라서 마지막 요소의 인덱스는 요소의 개수에서 1을 빼줍니다.
    그리고 0까지 반복할 수 있도록 조건식을 i >= 0와 같이 해 줍니다.
    */

    /** 세로 크기 - 1 부터 역순으로 반복*/
    for (int i = row - 1; i >= 0; i--)
    {
        /** 가로 크기 - 1 부터 역순으로 반복*/
        for (int j = col - 1; j >= 0; j--)
        {
            /** 2차원 배열의 인덱스에 반복문의 변수 i, j를 지정*/
            cout << numArr[i][j] << " ";
        }
        /** 가로 요소를 출력한 뒤에 다음 줄로 넘어갑니다. */
        cout << "" << endl;
    }

    cout << "" << endl;
    cout << "" << endl;

    /** 포인터 배열 : 포인터들을 배열에 저장합니다. */
    int num1 = 100;
    int num2 = 200;
    int num3 = 300;

    int intArr1[3] = { num1, num2, num3 };

    for (int i = 0; i < size(intArr1); i++)
    {
        cout << "address : " << &intArr1[i] << ", value : " << intArr1[i] << endl;
    }

    cout << "" << endl;
    cout << "" << endl;

    /** 포인터 배열은 틀립니다. */

    int* arr[3] = { &num1, &num2, &num3 };

    for (int i = 0; i < size(arr); i++)
    {
        cout << "address : " << arr[i] << ", value : " << *arr[i] << endl;
    }

    cout << "" << endl;
    cout << "" << endl;

    /**
    1. 2차원 배열에 배열들의 요소들을 출력해 보았습니다.
    2. 정수값을 포인터 배열에 저장해서 요소들을 출력해 보았습니다.
    3. 포인터배열의 장점은 하나가 아닌 여러개의 배열을 한번에 처리할 수 있는 장점이 있습니다.,
        배열을 포인터배열에 저장해서 요소들을 출력해 봅니다.
    */

    /**
    2차원 배열에서는 세로 크기와 가로 크기가 동일했습니다.
    각각의 배열들의 사이즈가 클리더라도 포인터배열은 배열을 저장하는 것이고
    배열의 포인터를 저장하는 것이라 배열들의 사이즈가 틀리더라도 가능합니다.
    */
    int intArr2[5] = { 1, 2, 3, 4, 5 };
    int intArr3[6] = { 10, 20, 30, 40, 50, 60 };
    int intArr4[7] = { 100, 200, 300, 400, 500, 600, 700 };

    /**
    포인터배열을 선언하고 각각의 주소값을 대입해 줍니다.
    배열의 이름은 배열의 시작주소(배열의 0번째 인덱스 값의 주소)이므로 배열이름으로
    주소값을 대입한 것과 동일합니다.
    */
    int* ptrArr[3] = { intArr2, intArr3, intArr4 };
    /**
    세로 사이즈(행)를 구해 봅니다.
    세로 사이즈는 3입니다.
    */
    int length = size(ptrArr);
    /**
    가로 사이즈(열)를 구해 봅니다.
    배열의 사이즈가 틀리니 가로 사이즈는 배열로 만들어 줍니다.
    가로 사이즈는 배열 {5, 6, 7} 입니다.
    */
    int subLength[3] = { size(intArr2), size(intArr3), size(intArr4) };
    /** 포인터배열의 세로 사이즈만큼 반복합니다. */
    for (int i = 0; i < length; i++)
    {
        /**
        포인터배열의 가로 사이즈만큼 반복합니다.
        가로 사이즈는 배열 크기가 모두 달라서 subLength배열에서 인덱스로 접근합니다.
        */
        for (int j = 0; j < subLength[i]; j++)
        {
            /** 포인터 배열의 인덱스에 반복문의 i와 j를 지정합니다. */
            cout << ptrArr[i][j] << " ";
        }
        /** 가로 요소를 출력한 뒤에 다음 줄로 넘어갑니다. */
        cout << "" << endl;
    }

    cout << "" << endl;
    cout << "" << endl;

    /** 문자열로 된 배열을 포인터배열에 추가해 줍니다. */
    string names[5] = { "Tom", "John", "Jane", "Smith", "James" };
    string nations[3] = { "Korea", "Japan", "China" };
    string animals[6] = { "Tiger", "Lion", "Dog", "Cat", "Ang", "Pig" };

    /**
    포인터배열에 각각의 주소값을 대입합니다.
    배열의 이름은 배열의 시작주소(배열의 0번째 인덱스 값의 주소)입니다.
    */
    string* ptrArr1[3] = { names, nations, animals };
    /** 세로 사이즈(행, Row)를 구합니다. */
    int strLength = size(ptrArr1);
    /**
    가로 사이즈(열, Column)를 구합니다.
    배열들의 사이즈들이 모두 틀려서 배열에서 가로 사이즈를 구합니다.
    */
    int strSubLength[3] = { size(names), size(nations), size(animals) };

    /** 포인터배열의 가로 사이즈만큼 반복합니다. */
    for (int i = 0; i < strLength; i++)
    {
        /** 포인터배열의 세로 사이즈만큼 반복합니다. */
        for (int j = 0; j < strSubLength[i]; j++)
        {
            /**
            반복문의 변수 i와 j는 증감문을 통해서 1씩 증가하므로 포인터배열의 세로 인덱스에는 i의 값을
            포인터배열의 가로 인덱스에는 j의 값을 넣으면 포인터배열의 요소를 순서대로 접근할 수 있습니다
            */
            cout << ptrArr1[i][j] << " ";
        }
        /** 가로 요소를 출력한 뒤에 다음 줄로 넘어값니다. */
        cout << "" << endl;
    }

    cout << "" << endl;
    cout << "" << endl;

}
#include <iostream>

/** 문자열 관련 라이브러리*/
#include <string>

/** C++ 표준 라이브러리 사용합니다. */
using namespace std;

/** 테스트를 위해서 Parent1, Child1이라는 이름의 클래스를 정의해줍니다. */
class Parent1
{
private: // 개인적인
    /**
    객체 지향 언어에서 멤버 변수는 private 접근 지정자 안에 두어서 멤버 변수를 보호합니다. 캡슐화
    멤버 함수를 통해서만 멤버 변수에 접근할 수 있습니다.
    자식 클래스에서 조차도 부모 클래스의 private 접근 지정자 안에 있는 멤버 변수에 접근이 안 됩니다.
    다른 클래스에서는 멤버 변수에 직접적으로 접근이 불가능하게 해서 멤버 변수를 보호하는 것입니다.
    멤버 변수는 변수의 이름만 보더라도 멤버 변수인 것을 알 수 있도록 m, m_, _를 변수 이름 앞에 붙여줍니다.
    */

    /**
    Parent1클래스는 자식도 아닌 자신만이 접근이 가능한 멤버 변수
    m_IntValue1, m_IntValue2, m_IntValue3을 가지고 있습니다.
    private 접근 지정자 안에 있기 때문에 자식 클래스에서도 멤버 변수에 접근할 수가 없습니다.
    */
    int m_IntValue1;
    int m_IntValue2;
    int m_IntValue3;
public: // 공개적인
    /**
    Parent1이라는 이름의 생성자 함수를 정의합니다.
    Parent1이라는 이름의 생성자 함수의 원형을 선언합니다. // (X) 이미 함수의 본체가 있기 때문입니다.
    매개 변수가 없는 디폴트 생성자입니다.
    */
    Parent1() {}

    /**
    생성자로 초기화를 하는 방법은 2가지가 있습니다.
    1. 일반적인 생성자를 사용해서 초기화를 하는 방법입니다.
    생성자를 사용해서 생성자 내부에서 클래스 멤버 변수들을 초기화 합니다.
    m_IntValue1, m_IntValue2 멤버 변수들을 초기화 합니다.
    */
    Parent1(int value1, int value2)
    {
        m_IntValue1 = value1;
        m_IntValue2 = value2;
    }
};

int main()
{
    /**
    객체 지향 언어의 4가지 특징
    1. 캡슐화 : 접근 지정자(private, protected, public)
    2. 상속
    3. 다형성 : 연산자 오버로딩, 함수 오버로딩, 함수 오버라이딩(함수 재정의)
                                                함수 오버라이딩 : 가상 함수와 동적 바인딩
    4. 추상화 : 순수 가상함수와 추상클래스
    */

    /**
    구조체
    주로 데이터(멤버 변수)만 넣습니다.
    C++에서는 구조체에 함수를 넣을 수 있지만 C에서는 안 됩니다.
    C++에서 구조체는 클래스와 기능적으로 동일합니다.
    멤버 변수 뿐만 아니라 생성자와 소멸자를 비롯한 멤버 함수를 가질 수 있으며
    다른 구조체나 클래스를 상속 가능하고, 다른 클래스나 구조체를 상속받을 수 있습니다.
    멤버들은 접근 지정자로 지정되며 멤버 활용 방법 또한 클래스와 동일합니다.
    하나 틀린 점은 접근 지정자를 지정하지 않으면 디폴트로 public입니다.
    
    C언어와의 호환성을 위해서, 모든 멤버들이 공개적인 C언어의 구조체를 C++에서 수용하기 위함입니다.
    */

    /**
    클래스
    접근 지정자 private, protected, public으로 멤버 변수와 멤버 함수의 접근 가능 정도를
    설정할 수 있습니다.
    데이터(멤버 변수), 기능(멤버 함수를 가집니다. )
    하나 틀린 점은 접근 지정자를 지정하지 않으면 디폴트로 private입니다.
    */

    /**
    상속(Inheritance)
    객체 지향 언어에서는 부모 클래스의 멤버 변수와 멤버 함수를 자식 클래스에서
    재사용이 가능합니다.
    멤버 변수나 멤버 함수를 접근 제한자를 두어서 아무나 접근할 수 없도록 할 수 있습니다.
    상속하는 방법은 : (콜론)을 사용합니다.

    다른 클래스의 데이터(멤버 변수), 기능(멤버 함수)을 인계해서 새로운 클래스를 정의하는 것입니다.
    자식 클래스에서는 부모 클래스로부터 상속받은 멤버 이외에 자신만의 새로운 멤버들을 추가해서 사용이 가능합니다.

    한가지 단점은 상속을 많이 하게 되면 코드 분석이 어렵게 됩니다.
    */

    /**
    생성자(Constructor)
    클래스가 객체를 생성할 때 호출되는 멤버 함수입니다.
    클래스가 메모리에 생성되면 객체(인스턴스, instance)가 됩니다.
    객체를 생성할 때 다양하게 멤버 변수들의 초기화를 해 줍니다.
    자신의 클래스 이름과 동일하지만 반환이 없는 함수입니다.
    생성자를 사용하려면 반드시 public으로 해야 합니다.
    public으로 하는 이유는 모든 곳에서 접근이 가능해야 초기화를 하고 객체를 생성할 수 있기 때문입니다.
    */

    /**
    소멸자(Destructor)
    소멸자는 객체가 메모리에서 해제될 때 할 일들을 기록하는 멤버 함수입니다.
    당연히 반환값, 전달받는 매개 변수 없습니다. ~클래스이름() 의 형태이어야 합니다.
    ~ : 틸드
    delete 연산자로 객체를 메모리에서 해제시켜 주어야 하는데, 소멸자에서 이런 작업들을 하게 됩니다.
    */

    /** 테스트를 위해서 Parent1, Child1이라는 이름의 클래스를 정의해줍니다. */
}


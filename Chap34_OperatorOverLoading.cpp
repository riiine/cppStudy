#include <iostream>

/** 문자열 관련 라이브러리 */
#include <string>

/** C++ 표준 라이브러리 사용합니다. */
using namespace std;

/** 테스트를 위해서 Point1이라는 이름의 클래스를 정의해줍니다. */
class Point1
{
private:
    int m_xPosition;
    int m_yPosition;
public:
    /**
    생성자의 목적은 객체를 생성하면서 멤버 변수의 초기화를 담당합니다.
    : 콜론 뒤의 내용이 초기화 리스트로 멤버 변수를 초기화하는 과정입니다.
    */
    Point1(int x, int y) : m_xPosition(x), m_yPosition(y) {}
    /** ShowPosition라는 이름의 함수의 원형을 선언합니다.*/
    void ShowPosition();
};

int main()
{
    /**
    연산자 오버로딩(Operator Overloading)이란?

    1. 함수의 오버로딩 : 동일한 이름의 함수에 매개변수의 개수, 타입 등을 다르게 하여
                         여러 개를 정의할 수 있습니다.
    2. 연산자의 오버로딩 : 하나의 연산자를 다른 기능도 사용할 수 있도록 사용자 정의
                           클래스를 사용합니다.

    다음과 같은 연산자 이외에 모든 연산자는 재정의가 가능합니다.

    :: 범위 지정 연산자
    . 멤버 참조 연산자
    * 멤버 포인터 연산자
    ? 삼항 연산자
    # 전처리기 변환
    ## 전처리기 연결

    멤버 함수로만 오버로딩 가능한 연산자로 존재합니다.

    = 대입 연산자
    () 함수 호출
    -> 포인터 멤버 접근 연산자
    [] 배열 인덱스 연산자
    */

    /**
    연산자 오버로딩 규칙

    1. 기본 데이터 타입만을 다루는 연산자 오버로딩은 할 수 없습니다. 
       피 연산자 중 하나는 반드시 사용자 정의 타입이어야 합니다.
       int + int는 오버로딩을 통해서 다른 결과를 낼 수가 없습니다.
    2. 비정적 클래스 멤버 함수 또는 전역 함수이어야 연산자 오버로딩이 가능합니다.
    3. 단항 연산자 또는 이항 연산자로 오버로딩 할 수 있습니다.
    4. 오버 로딩된 연산자는 디폴트 매개변수는 사용 불가능합니다.

    반환타입 operator오버로딩할 연산자(매개변수1, 매개변수2, ...) { 연산자 가능}
    */

    /** 연산자는 산술 연산자(+, -, *, /, %), 비교 연산자(==, !=), 증감 연산자(++, --)*/

    /** 1 산술 연산자(+, -, *, /, %) 오버로딩에 대해서 알아봅니다. */

    /** 테스트를 위해서 Point1이라는 이름의 클래스를 정의해줍니다. */
}

void Point1::ShowPosition()
{
    cout << "m_xPosition : " << m_xPosition << ", m_yPosition : " << m_yPosition << endl;
}

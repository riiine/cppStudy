#include <iostream>

/** 문자열 관련 라이브러리 */
#include <string>
/** 스마트 포인터 관련 라이브러리 */
#include <memory>
/** 벡터 컨테이너 관련 라이브러리 */
#include <vector>

/** C++ 표준 라이브러리 사용합니다. */
using namespace std;

/** 정적 할당을 테스트 해보기 위해서 Animal이라는 이름의 클래스를 정의해주도록 합니다. */
class Animal
{
public:
    /** 
    객체를 생성하기 위해서는 생성자 함수를 호출합니다. 
    객체를 생성하면서 멤버 변수의 초기화를 담당합니다.
    */
    Animal()
    {
        cout << "정적 할당으로 객체 생성한 생성자" << endl;
    }

    /**
    객체가 메모리에서 해제되면 소멸자 함수가 호출됩니다.
    객체가 메모리에서 해제될 때 할 일들을 정해줍니다.
    */
    ~Animal()
    {
        cout << "정적 할당으로 객체 해제된 소멸자" << endl;
    }
};

/** new 연산자를 이용한 동적 할당을 테스트 해보기 위해서 Lion이라는 이름의 클래스를 정의해 주도록 합니다. */
class Lion
{
public:
    Lion()
    {
        cout << "new 연산자로 동적으로 객체 생성한 생성자" << endl;
    }

    ~Lion()
    {
        cout << "new 연산자로 동적으로 객체 해제한 소멸자" << endl;
    }
};

/**
스마트 포인터로 동적으로 객체 생성을 해봅니다.

테스트를 위해서 Tiger라는 이름의 클래스를 정의해 주도록 합니다.
*/
class Tiger
{
public:
    Tiger()
    {
        cout << "스마트 포인터로 동적으로 객체생성한 생성자" << endl;
    }
    
    ~Tiger()
    {
        cout << "스마트 포인터로 동적으로 객체해제한 소멸자" << endl;
    }
};

int main()
{
    /**
    구글 검색 없이 자연스럽게 써야하는 문법적 요소
    1. 포인터          Pointer
    2. 참조자          Reference
    3. 상수            Constant
    4. 동적할당        Dynamic Memory Allocation
    5. 스마트 포인터
        unique_ptr : 객체의 유일한 소유권을 가지는 스마트 포인터
        shared_ptr : 객체 간의 공유가 가능한 스마트 포인터
        weak_ptr   : shared_ptr의 고질적인 순환 참조 문제를 해결한 약한 참조의 스마트 포인터
        auto_ptr   : 2017에 없어졌습니다.
    */

    /**
    C++에서 객체 생성 방법

    1. 정적 할당 : 미리 할당을 합니다. 쓰지 않더라도 미리 할당을 합니다.
                   비효율적인 부분이 발생할 수 있습니다. 하지만 내가 메모리 관리를 할 필요가 없습니다.

    2. 동적 할당 : 런타임에서 메모리 할당을 합니다. 효율적으로 필요한 부분에서 메모리 할당을 합니다.
                   까다로운 부분이 있습니다. 하지만 효율을 위해서 동적으로 객체 생성을 해야만 합니다.
        A. new 연산자로 객체 생성을 합니다. delete 연산자로 객체 해제를 해주어야 합니다.
            만일 delete 연산자로 객체 해제를 해주지 않으면 메모리 누수가 발생합니다.
            계속 메모리에 쓰레기가 쌓여서 프로그램이 crash될 수도 있습니다.
            메모리 누수 : 내가 접근할 수 없는, 내가 지울수 없는 쓰레기 객체들이 메모리에 계속 쌓입니다.
                          나중에는 앱이나 게임이 강제로 종료될 수도 있습니다.
                          이 부분 때문에 C++에서는 경험이 많이 필요했습니다.
        B. 2011년도에 스마트 포인터를 지원하면서 메모리 관리가 너무 편해졌습니다.
           내가 객체 해제를 해 줄 필요가 없습니다.
           메모리 누수 발생을 원천적으로 예방할 수 있습니다.
    */

    /** 정적 할당을 테스트 해보기 위해서 Animal이라는 이름의 클래스를 정의해주도록 합니다. */

    /** 문장을 추가해줍니다. */
    Animal animal1;
    cout << "" << endl;

    /** new 연산자를 이용한 동적 할당을 테스트 해보기 위해서 Lion이라는 이름의 클래스를 정의해 주도록 합니다. */

    /** 문장을 추가해줍니다. */
    Lion* lion1 = new Lion();
    cout << "" << endl;

    /** 추가 내용 있습니다. */
    delete lion1;
    cout << "" << endl;

    /**
    스마트 포인터로 동적으로 객체 생성을 해봅니다.

    테스트를 위해서 Tiger라는 이름의 클래스를 정의해 주도록 합니다.
    */

    /** 문장을 추가해줍니다. */
    unique_ptr<Tiger> uniquePtr1 = make_unique<Tiger>();
    cout << "" << endl;
}

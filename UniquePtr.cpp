#include <iostream>

/** 문자열 관련 라이브러리*/
#include <string>
/** 스마트 포인터 관련 라이브러리*/
#include <memory>
/** 벡터 컨테이너 관련 라이브러리*/
#include <vector>

/** C++ 표준 라이브러리 사용합니다. */
using namespace std;

/** 정적 할당을 테스트 해 보기 위해서 Animal이라는 이름의 클래스를 정의해 주도록 합니다. */
class Animal
{
public:
    /**
    객체를 생성하기 위해서는 생성자 함수를 호출합니다.
    객체를 생성하면서 멤버 변수의 초기화를 담당합니다.
    */
    Animal()
    {
        cout << "정적 할당으로 객체 생성한 생성자" << endl;
    }

    /**
    객체가 메모리에서 해제되면 소멸자 함수가 호출됩니다.
    객체가 메모리에서 해제될 때 할 일들을 정해 줍니다.
    */
    ~Animal()
    {
        cout << "정적 할당으로 객체 해제된 소멸자" << endl;
    }
};

/** new 연산자를 이동한 동적 할당을 테스트 해 보기 위해서 Lion이라는 이름의 클래스를 정의해 주도록 합니다. */
class Lion
{
public:
    Lion()
    {
        cout << "new 연산자로 동적으로 객체 생성한 생성자" << endl;
    }

    ~Lion()
    {
        cout << "new 연산자로 동적으로 객체 해제한 소멸자" << endl;
    }
};

/**
스마트 포인터로 동적으로 객체 생성을 해 봅니다.

테스트를 위해서 Tiger라는 이름의 클래스를 정의해 주도록 합니다.
*/
class Tiger
{
public:
    Tiger()
    {
        cout << "스마트 포인터로 동적으로 객체 생성한 생성자" << endl;
    }

    ~Tiger()
    {
        cout << "스마트 포인터로 동적으로 객체 해제한 소멸자" << endl;
    }
};

/** 테스트를 위해서 Cat이라는 이름의 클래스를 정의해 주도록 합니다. */
class Cat
{
private:
    int* m_Food;
public:
    Cat()
    {
        /**
        생성자는 객체를 생성하면서 멤버 변수의 초기화를 담당합니다.
        생성자에서 사이즈가 10000인 배열을 동적 할당으로 선언했습니다.
        */
        m_Food = new int[10000];
        cout << "Cat 생성자" << endl;
    }

    ~Cat()
    {
        /**
        소멸자는 객체가 메모리에서 해제되면 호출됩니다.
        객체가 메모리에서 해제될 때 할 일들을 지정해 줍니다.
        소멸자에서 사이즈가 10000인 배열을 delete 연산자로 객체 해제를 해주지 않으면 4byte * 10000의 메모리 누수가 발생합니다.
        */
        // delete m_Food;
        cout << "Cat 소멸자" << endl;
    }
};

int main()
{
    /**
    구글 검색없이 자연스럽게 써야 하는 문법적 요소
    1. 포인터  Pointer
    2. 참조자  Reference
    3. 상수   Constant
    4. 동적할당 Dynamic Memory Allocation
    5. 스마트 포인터
        unique_ptr : 객체의 유일한 소유권을 가지는 스마트 포인터
        shared_ptr : 객체간의 공유가 가능한 스마트 포인트
        weak_ptr    : shared_ptr의 고질적인 순환 참조 문제를 해결한 약한 참조의 스마트 포인터
        auto_ptr   : 2017에 없어졌습니다.
    */

    /**
    C++에서 객체 생성 방법

    1. 정적 할당 : 미리 할당을 합니다. 쓰지 않더라도 미리 할당을 합니다.
            비효율적인 부분이 발생할 수 있습니다. 하지만 내가 메모리 관리를 할 필요가 없습니다.

    2. 동적 할당 : 런타임에서 메모리 할당을 합니다. 효율적으로 필요한 부분에서 메모리 할당을 합니다.
            까다로운 부분이 있습니다. 하지만 효율을 위해서 동적으로 객체 생성을 해야만 합니다.
        A. new 연산자로 객체 생성을 합니다. delete 연산자로 객체 해제를 해야 주어야 합니다.
            만일 delete 연산자로 객체 해제를 해주지 않으면 메모리 누수가 발생합니다.
            계속 메모리에 쓰레기가 쌓여서 프로그램이 crash될 수도 있습니다.
            메모리 누수 : 내가 접근할 수 없는, 내가 지울수 없는 쓰레기 객체들이 메모리에 계속 쌓입니다.
                나중에는 앱이나 게임이 강제로 종료될 수도 있습니다.
                이 부분 때문에 C++에서는 경험이 많이 필요했습니다.
        B. 2011년도에 스마트 포인터를 지원하면서 메모리 관리가 너무 편해졌습니다.
            내가 객체 해제를 해 줄 필요가 없습니다.
            메모리 누수 발생을 원천적으로 예방할 수 있습니다.
    */

    /** 정적 할당을 테스트 해 보기 위해서 Animal이라는 이름의 클래스를 정의해 주도록 합니다. */

    /** 문장을 추가해 줍니다. */
    Animal animal1;
    cout << "" << endl;

    /** new 연산자를 이동한 동적 할당을 테스트 해 보기 위해서 Lion이라는 이름의 클래스를 정의해 주도록 합니다. */

    /** 문장을 추가해 줍니다. */
    Lion* lion1 = new Lion();
    cout << "" << endl;

    /** 추가 내용 있습니다. */
    delete lion1;
    cout << "" << endl;

    /**
    스마트 포인터로 동적으로 객체 생성을 해 봅니다.

    테스트를 위해서 Tiger라는 이름의 클래스를 정의해 주도록 합니다.
    */

    /** 문장을 추가해 줍니다. */
    unique_ptr<Tiger> uniquePtr1 = make_unique<Tiger>();
    cout << "" << endl;

    /**
    delete 연산자 사용의 복잡성과 메모리 누수 예방을 위해서 스마트 포인터가 생겼습니다.

    1. unique_ptr : C++ 11 (2011년) 에 추가 되었습니다. 객체의 유일한 소유권을 가지는 스마트 포인터
    2. shared_ptr : C++ 11 (2011년) 에 추가 되었습니다. 객체간의 공유가 가능한 스마트 포인트
    3. weak_ptr   : C++ 11 (2011년) 에 추가 되었습니다. shared_ptr의 순환 참조 문제를 해결한
                약한 참조의 스마트 포인터
    4. auto_ptr   : C++ 17 (2017년) 에 없어졌습니다.

    C언어 malloc(말록, Memory Allocation)함수, free() 함수로 메모리 관리르 했습니다.
    C++에서는 new 연산자, delete 연산자로 메모리 관리를 하지만 어렵습니다. 테스트를 많이 해야만 합니다.
    메모리 누수를 체크하는 많은 툴들이 있지만 아직도 복잡합니다.

    2011년에 스마트 포인터를 지원하면서 메모리 관리가 너무 쉬워졌습니다.
    */

    /**
    자원 관리의 중요성

    메모리를 할당만 하고 헤제를 하지 않는다면 결국 메모리 부족으로 프로그램이 crash될 수도 있습니다.
    C++ 이후에 나온 많은 언어들은 대부분 가비지 컬렉터(자원 청소기)를 지원합니다.
    가비지 컬렉터가 1초에 몇십번 호출되어서 메모리에 접근이 안되는 쓰레기 자원들을 정리합니다.

    따라서 프로그래머들이 자원을 해제하는 일에 대해 신경쓰지 않아도 되는 장점이 있읍니다만
    느립니다.
    */

    /** 테스트를 위해서 Cat이라는 이름의 클래스를 정의해 주도록 합니다. */

    /** 문장을 추가해 줍니다. */

    /**
    생성자 함수에서 엄청 사이즈가 큰 배열을 정의하고 있습니다.
    Cat()
    {
        m_Food = new int[10000];
        cout << "Cat 생성자" << endl;
    }

    객체가 생성만 되고, 생성된 객체가 해제되지 않았습니다.
    메모리 누수가 발생하는데, 얼마만큼의 메모리 누수가 발생할까요?
    m_Food = new int[10000];
    int 타입은 4바이트입니다. 4byte * 10000 = 40000바이트

    Cat이라는 객체가 생성될 때마다 40000바이트의 메모리 누수가 계속 발생합니다.

    Heap 메모리 공간 어딘가에 Cat 객체가 남아있지만 그 주소값을 가지고 있는 포인터는 메모리 상에 존재하지 않습니다.
    Cat 객체는 영원히 해제되지 않는 채로 Heap 메모리 공간에서 자리만 차지합니다.

    delete 연산자로 메모리 해제 해주면 되지 않겠냐 하겠지만 프로그램의 크기가 커지면 자원을 해제하는 위치가
    복잡할 수 있습니다. 놓치기 쉽습니다.
    */
    Cat* cat1 = new Cat();
    cout << "" << endl;

    delete cat1;
    cout << "" << endl;

    /** 메모리 누수가 없어졌나요? */

    /**
    unique_ptr : 객체의 유일한 소유권을 가지는 스마트 포인터

    C++ 에서 메모리 관리를 잘못 했을 때 2가지 문제점이 발생할 수 있습니다.

    1. 메모리를 사용한 후에 해제하지 않는 경우입니다. 메모리 누수(memory leak)입니다.
    2. 이미 해제된 메모리를 다시 참조하는 경우입니다.
        이미 해제된 메모리는 nullptr가 됩니다. nullptr인 객체에 접근하면 에러가 생깁니다.
    */

    /**
    이미 해제된 메모리를 다시 참조했을 때의 경우입니다.

    문장을 추가해 줍니다.
    */
    Cat* cat2 = new Cat();
    cout << "" << endl;

    /** 포인터 변수들을 같은 객체를 가리킬 수 있습니다. */
    Cat* cat3 = cat2;
    cout << "" << endl;

    /**
    cat2와 cat3는 동시에 한 객체를 가리키고 있습니다.
    delete cat2를 통해서 객체를 소멸시켜 주었습니다.
    그런데 cat3가 이미 소멸된 객체를 다시 소멸시키려고 합니다. 에러가 생깁니다.
    이미 소멸된 객체를 다시 소멸시켜서 발생하는 버그를 double free 버그라고 합니다.
    이와 같은 문제가 발생하는 이유는 생성된 객체의 소유권이 명확하지 않아서 생깁니다.
    만약에 우리가 어떤 포인터에 객체의 유일한 소유권을 부여해서 이 포인터 말고는 객체를 소멸시킬 수
    없다라고 한다면 같은 객체를 두 번 소멸시켜 보리는 일을 발생하지 않을 것입니다.
    */

    /** cat2 객체가 동적으로 생성되었으니 메모리에서 객체 해제를 해 줍니다. */
    delete cat2;
    cout << "" << endl;

    /**
    cat3 객체도 동적으로 생성되었으니 메모리에서 객체 해제를 해 줍니다.

    문법적으로는 이상이 없어 보입니다. 컴파일 에러가 없습니다.
    하지만 플레이 하면 에러가 생깁니다. 런타임 에러는 조심해야 합니다.
    */
    // delete cat3; // (X)
    cout << "" << endl;

    /**
    위의 경우를 보면 cat2에 new Cat() 으로 생성된 객체의 소유권을 보유한다면
    delete cat2는 가능하고
    delete cat3는 불가능하게 됩니다.

    특정 객체에 유일한 소유권을 부여하는 스마트 포인터를 unique_ptr라고 합니다.

    문장을 추가해 줍니다.
    */
    unique_ptr<Cat> uniquePtr2(new Cat());
    cout << "" << endl;

    /**
    unique_ptr들이 같은 객체를 가리키면 어떻게 될까요?
    만약에 unique_ptr를 복사하려고 한다면?

    문장을 추가해 줍니다.
    */
    unique_ptr<Cat> uniquePtr3(new Cat());
    cout << "" << endl;
    /** uniquePtr4가 uniquePtr3를 가리킬 수 있을 까요? */
    // unique_ptr<Cat> uniquePtr4 = uniquePtr3; // (X)
    cout << "" << endl;

    /**
    unique_ptr 소유권 이전하기에 대해서 알아 봅니다.

    unique_ptr는 복사는 불가능하지만 소유권을 이전할 수 있습니다.

    문장을 추가해 줍니다.
    */
    /**
    uniquePtr3를 uniquePtr4로 강제로 이동 시켜 버립니다. 소유권 이전입니다.
    uniquePtr4는 new Cat()으로 생성된 객체의 소유권을 갖게 되고, uniquePtr3는 아무 것도 가리키고 있지 읺게 됩니다.
    */
    unique_ptr<Cat> uniquePtr4 = move(uniquePtr3);
    cout << "" << endl;

    /** get() 함수를 이용하면 실제 객체의 주소값을 반환해 줍니다. */
    cout << "uniquePtr3 : " << uniquePtr3.get() << endl;
    cout << "uniquePtr4 : " << uniquePtr4.get() << endl;
    cout << "" << endl;

    /**
    unique_ptr를 사용하면서 주의 사항입니다.

    소유권이 이전된 unique_ptr를 댕글링 포인터(dangling pointer)라고 합니다.
    이를 재 참조할 시에 런타임 에러가 발생합니다.
    따라서 소유권 이전은 댕글링 포인터를 절대 다시 참조하지 않겠다는 확신하에서 이동해야 합니다.

    소유권을 이동 시킨 후에 원래의 unique_ptr에 접근하지 않도록 조심해야 합니다.
    */

    /**
    unique_ptr를 안전하게 생성하기
    C++ 14 (2014년) 부터 unique_ptr 객체를 안전하게 생성할 수 있는 make_uniqueA() 함수를 제공합니다.

    문장을 추가해 줍니다.
    */
    unique_ptr<Cat> uniquePtr5 = make_unique<Cat>();
    cout << "" << endl;

    /**
    Visual C++
    C++ 11 (2011년)
    C++ 14 (2014년)
    C++ 17 (2017년)
    C++ 20 (2020년)
    */

    /**
    unique_ptr를 요소로 가지는 컨테이너에 대해서 알아 봅니다

    문장을 추가해 줍니다.
    */
    vector<unique_ptr<Cat>> vector5;
    unique_ptr<Cat> uniquePtr6(new Cat());
    cout << "" << endl;

    /**
    빌드하면 에러가 생깁니다. 에러가 나는 이유는 당연합니다.
    삭제된 unique_ptr의 복사 생성자에 접근하였기 때문입니다.
    기본적으로 vector의 push_back() 함수는 전달된 매개 변수를 복사해서 전달하기 때문에
    이와 같은 문제가 발생합니다.
    unique_ptr는 소유권이 유일해야 합니다. 매개 변수에 복사해서 전달하면 유일하지 않습니다.
    unique_ptr는 move() 함수를 통해서 소유권을 이전해서 vector 컨테이너에 전달해 주어야 합니다.
    */
    // vector5.push_back(uniquePtr6); // (X)

    /** 이를 방지하기 위해서는 명시적으로 uniquePtr6를 vector 컨테이너 안으로 이동시켜 주어야 합니다. */
    vector5.push_back(move(uniquePtr6));
    cout << "" << endl;

    /**
    emplace_back() 함수 : emplace_back() 함수를 이용하면 vector 컨테이너에 unique_ptr 객체를
    직접 생성하면서 넣을 수도 있습니다. 불필요한 이동 과정을 생략할 수 도 있습니다.

    문장을 추가해 줍니다.
    */
    vector<unique_ptr<Cat>> vector6;
    vector6.push_back(unique_ptr<Cat>(new Cat()));
    cout << "" << endl;

    /**
    emplace_back() 함수는 전달된 매개 변수를 직접 unique_ptr<Cat>의 생성자에 전달해서
    vector 컨테이너의 맨 뒤에 unique_ptr<Cat> 객체를 생성합니다.
    따라서 불필요한 이동 연산이 필요없게 됩니다.
    */
    vector6.emplace_back(new Cat());
    cout << "" << endl;
}